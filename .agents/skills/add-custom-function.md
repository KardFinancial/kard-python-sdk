# Add Custom Function to Kard Python SDK

This SDK is generated by Fern. Custom functions live alongside the auto-generated code but must be protected from regeneration. Follow these steps exactly.

## Reference Implementation

Study these files before writing anything:

- `src/kard/hem.py` -- canonical example of a custom function module
- `tests/custom/test_hem.py` -- canonical example of custom function tests
- `tests/custom/test_vectors.json` -- canonical example of JSON test vectors
- `.fernignore` -- list of files Fern must not overwrite

## Step 1: Create the Function Module

Create `src/kard/{name}.py` where `{name}` is a short, descriptive snake_case name.

Rules:

- **Prefer stdlib imports.** The SDK ships with httpx, pydantic, and typing_extensions -- those are safe to use. For anything else, check `pyproject.toml [tool.poetry.dependencies]` first. If the function genuinely requires a package that is not already a dependency, see [Adding Custom Dependencies](#adding-custom-dependencies) below.
- **Python 3.8+ compatible.** No walrus operator, no `dict | dict` union syntax, no `type` statement, no `match/case`. Use `typing.Union`, `typing.Optional`, `typing.List`, `typing.Dict` instead of built-in generics for type hints (e.g., `list[str]` is 3.9+).
- **Input validation pattern.** Check argument types with `isinstance` and raise `TypeError` with message `f"Expected a string, got {type(raw).__name__}"`. Validate values and raise `ValueError` with descriptive messages. Follow the exact pattern in `src/kard/hem.py`.
- **Docstrings.** Every public function gets a Google-style docstring with a summary line, description of behavior, and a `Raises:` section listing each exception type and when it is raised. See `normalize_email` in `src/kard/hem.py`.
- **Type hints on all function signatures.** Parameter types and return types are required.
- **Module-level constants** use `UPPER_SNAKE_CASE` with a leading underscore if private (e.g., `_GMAIL_DOMAINS`).
- **Ruff compliance.** Line length limit is 120. Linting rules: E (pycodestyle), F (pyflakes), I (isort). Isort section order: future, standard-library, third-party, first-party. Run `ruff check src/kard/{name}.py` to verify.
- **Mypy compliance.** The project uses `mypy` with the pydantic plugin. Ensure all types resolve. Run `mypy src/kard/{name}.py` to verify.

## Step 2: Protect the File from Fern Regeneration

Append the new module path to `.fernignore`:

```
src/kard/{name}.py
```

The file uses one path per line. Do not add blank lines between entries. Do not add comments on the same line as a path.

## Step 3: Create Tests

Create `tests/custom/test_{name}.py`.

Rules:

- **Import from the module directly:** `from kard.{name} import function_name` -- NOT via `__init__.py`, NOT via `from kard import function_name`.
- **Use `pytest.mark.parametrize`** for both happy-path and error cases. Give each parametrized case an `ids` list with human-readable names.
- **Error case tests** use `pytest.raises(ErrorType, match="substring")` pattern. Test at minimum: wrong type (TypeError) and at least two invalid value scenarios (ValueError). Follow the exact structure in `test_hem.py`.
- **If test vectors exceed ~10 cases or contain complex data**, put them in a JSON file at `tests/custom/test_{name}_vectors.json`. Load with:
  ```python
  import json
  import os

  _VECTORS_PATH = os.path.join(os.path.dirname(__file__), "test_{name}_vectors.json")

  with open(_VECTORS_PATH, encoding="utf-8") as f:
      vectors = json.load(f)
  ```
  The JSON file should be a list of objects. Each object must have a `"name"` field used for test IDs.
- **If test vectors are few and simple**, inline them directly in the parametrize decorator. No JSON file needed.
- **Return type annotation** on every test function: `-> None`.
- **Do not create a conftest.py** in `tests/custom/` unless fixtures are genuinely shared across multiple test files.

## Step 4: Do NOT Modify `__init__.py`

The file `src/kard/__init__.py` is auto-generated by Fern and uses a `_dynamic_imports` dict with a `__getattr__` hook. **Never edit this file.** Custom functions are imported directly from their module:

```python
# Correct:
from kard.hem import generate_hem

# Wrong -- do not do this:
from kard import generate_hem
```

## Step 5: Run Validation

Run these commands in order and fix any issues before considering the work done:

```bash
# 1. Lint
ruff check src/kard/{name}.py tests/custom/test_{name}.py

# 2. Type check
mypy src/kard/{name}.py

# 3. Tests (custom tests only, for speed)
python -m pytest tests/custom/test_{name}.py -v

# 4. Full test suite (make sure nothing is broken)
python -m pytest tests/ -v
```

All four must pass with zero errors and zero warnings.

## Adding Custom Dependencies

If a custom function legitimately requires an external package that is not already in `pyproject.toml`, you must register it with Fern so it is included when the SDK is regenerated and published.

In the Fern `generators.yml` configuration, add the package under `extra_dependencies` (production) or `extra_dev_dependencies` (test/dev only):

```yaml
- name: fernapi/fern-python-sdk
  version: "..."
  config:
    extra_dependencies:
      package-name: 'X.Y.Z'
    extra_dev_dependencies:
      test-only-package: 'X.Y.Z'
```

**Guidelines:**

- **Stdlib first.** Always check whether the standard library can do the job before adding a dependency. Fewer dependencies mean fewer version conflicts for SDK consumers.
- **Pin to a minimum version** (e.g., `'>=1.2.0'`) rather than an exact version, unless there is a specific compatibility reason.
- **Production vs dev.** If the package is only needed for tests, put it under `extra_dev_dependencies`. Only use `extra_dependencies` for packages that are imported by code in `src/kard/`.
- **Update `pyproject.toml` locally** as well so that `poetry install` and local development work. Fern will manage it on regeneration, but local dev needs it too.
- **Note:** `extra_dependencies` in `generators.yml` requires a Fern Pro or Enterprise plan. See [Fern docs on custom dependencies](https://buildwithfern.com/learn/sdks/generators/python/custom-code#adding-custom-dependencies) for details.

## Checklist

Before finishing, verify every item:

- [ ] `src/kard/{name}.py` exists with type hints, docstrings, and input validation
- [ ] Only stdlib/existing SDK imports are used, or new dependencies are registered in `generators.yml` and `pyproject.toml`
- [ ] All code is Python 3.8+ compatible (no 3.9+ syntax)
- [ ] `src/kard/{name}.py` is listed in `.fernignore`
- [ ] `tests/custom/test_{name}.py` exists with parametrized tests
- [ ] Test vectors JSON file exists (if applicable) with `encoding="utf-8"` in the open call
- [ ] Imports in tests use `from kard.{name} import ...` (direct module import)
- [ ] `src/kard/__init__.py` was NOT modified
- [ ] `ruff check` passes on all new files
- [ ] `mypy` passes on the new module
- [ ] `python -m pytest tests/custom/test_{name}.py -v` passes
- [ ] `python -m pytest tests/ -v` passes (full suite still green)
