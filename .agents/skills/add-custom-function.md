# Add Custom Function to Kard Python SDK

This SDK is generated by Fern. Custom functions live alongside the auto-generated code but must be protected from regeneration. Follow these steps exactly.

## Reference Implementation

Study these files before writing anything:

- `src/kard/hem.py` -- canonical example of a custom function module
- `tests/custom/test_hem.py` -- canonical example of custom function tests
- `tests/custom/test_vectors.json` -- canonical example of JSON test vectors
- `.fernignore` -- list of files Fern must not overwrite

## Step 1: Create the Function Module

Create `src/kard/{name}.py` where `{name}` is a short, descriptive snake_case name.

Rules:

- **Only stdlib imports.** No third-party dependencies. The SDK ships with httpx, pydantic, and typing_extensions, but custom utility functions must not depend on them unless they are working with SDK types. Check `requirements.txt` and `pyproject.toml [tool.poetry.dependencies]` if unsure.
- **Python 3.8+ compatible.** No walrus operator, no `dict | dict` union syntax, no `type` statement, no `match/case`. Use `typing.Union`, `typing.Optional`, `typing.List`, `typing.Dict` instead of built-in generics for type hints (e.g., `list[str]` is 3.9+).
- **Input validation pattern.** Check argument types with `isinstance` and raise `TypeError` with message `f"Expected a string, got {type(raw).__name__}"`. Validate values and raise `ValueError` with descriptive messages. Follow the exact pattern in `src/kard/hem.py`.
- **Docstrings.** Every public function gets a Google-style docstring with a summary line, description of behavior, and a `Raises:` section listing each exception type and when it is raised. See `normalize_email` in `src/kard/hem.py`.
- **Type hints on all function signatures.** Parameter types and return types are required.
- **Module-level constants** use `UPPER_SNAKE_CASE` with a leading underscore if private (e.g., `_GMAIL_DOMAINS`).
- **Ruff compliance.** Line length limit is 120. Linting rules: E (pycodestyle), F (pyflakes), I (isort). Isort section order: future, standard-library, third-party, first-party. Run `ruff check src/kard/{name}.py` to verify.
- **Mypy compliance.** The project uses `mypy` with the pydantic plugin. Ensure all types resolve. Run `mypy src/kard/{name}.py` to verify.

## Step 2: Protect the File from Fern Regeneration

Append the new module path to `.fernignore`:

```
src/kard/{name}.py
```

The file uses one path per line. Do not add blank lines between entries. Do not add comments on the same line as a path.

## Step 3: Create Tests

Create `tests/custom/test_{name}.py`.

Rules:

- **Import from the module directly:** `from kard.{name} import function_name` -- NOT via `__init__.py`, NOT via `from kard import function_name`.
- **Use `pytest.mark.parametrize`** for both happy-path and error cases. Give each parametrized case an `ids` list with human-readable names.
- **Error case tests** use `pytest.raises(ErrorType, match="substring")` pattern. Test at minimum: wrong type (TypeError) and at least two invalid value scenarios (ValueError). Follow the exact structure in `test_hem.py`.
- **If test vectors exceed ~10 cases or contain complex data**, put them in a JSON file at `tests/custom/test_{name}_vectors.json`. Load with:
  ```python
  import json
  import os

  _VECTORS_PATH = os.path.join(os.path.dirname(__file__), "test_{name}_vectors.json")

  with open(_VECTORS_PATH, encoding="utf-8") as f:
      vectors = json.load(f)
  ```
  The JSON file should be a list of objects. Each object must have a `"name"` field used for test IDs.
- **If test vectors are few and simple**, inline them directly in the parametrize decorator. No JSON file needed.
- **Return type annotation** on every test function: `-> None`.
- **Do not create a conftest.py** in `tests/custom/` unless fixtures are genuinely shared across multiple test files.

## Step 4: Do NOT Modify `__init__.py`

The file `src/kard/__init__.py` is auto-generated by Fern and uses a `_dynamic_imports` dict with a `__getattr__` hook. **Never edit this file.** Custom functions are imported directly from their module:

```python
# Correct:
from kard.hem import generate_hem

# Wrong -- do not do this:
from kard import generate_hem
```

## Step 5: Run Validation

Run these commands in order and fix any issues before considering the work done:

```bash
# 1. Lint
ruff check src/kard/{name}.py tests/custom/test_{name}.py

# 2. Type check
mypy src/kard/{name}.py

# 3. Tests (custom tests only, for speed)
python -m pytest tests/custom/test_{name}.py -v

# 4. Full test suite (make sure nothing is broken)
python -m pytest tests/ -v
```

All four must pass with zero errors and zero warnings.

## Checklist

Before finishing, verify every item:

- [ ] `src/kard/{name}.py` exists with type hints, docstrings, and input validation
- [ ] Only stdlib imports are used in the module
- [ ] All code is Python 3.8+ compatible (no 3.9+ syntax)
- [ ] `src/kard/{name}.py` is listed in `.fernignore`
- [ ] `tests/custom/test_{name}.py` exists with parametrized tests
- [ ] Test vectors JSON file exists (if applicable) with `encoding="utf-8"` in the open call
- [ ] Imports in tests use `from kard.{name} import ...` (direct module import)
- [ ] `src/kard/__init__.py` was NOT modified
- [ ] `ruff check` passes on all new files
- [ ] `mypy` passes on the new module
- [ ] `python -m pytest tests/custom/test_{name}.py -v` passes
- [ ] `python -m pytest tests/ -v` passes (full suite still green)
